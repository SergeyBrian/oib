#include "debugger.h"

#define VULN_FUNCTIONS_COUNT 2
#define MAX_BREAKPOINTS 100
#define OBJDUMP_ADDRESS_OFFSET 4
#define OBJDUMP_INSTRUCTION_OFFSET 10

static const char VULN_FUNCTIONS[VULN_FUNCTIONS_COUNT][20] = {
        "strcpy",
        "scanf"
};

typedef struct {
    int offset;
    int instruction;
    int is_active;
} Breakpoint;

typedef struct {
    char copy_filename[MAX_FILENAME];
    Breakpoint breakpoints[MAX_BREAKPOINTS];
    int breakpoint_count;
} Debugger;

static Debugger *debugger;

void debugger_init() {
    info("Initializing debugger");
    debugger = malloc(sizeof(Debugger));
    debugger->breakpoint_count = 0;
    strncpy(debugger->copy_filename, commonData->target_program_file_name, MAX_FILENAME);
    strncat(debugger->copy_filename, ".dbg", MAX_FILENAME);
    char copy_command[MAX_COMMAND] = "cp ";
    strncat(copy_command, commonData->target_program_file_name, MAX_COMMAND);
    strncat(copy_command, " ", MAX_COMMAND);
    strncat(copy_command, debugger->copy_filename, MAX_COMMAND);
    info("Creating a copy of target program");
    if (system(copy_command)) {
        error_exit(E_FAILED_COPY_TARGET_PROGRAM);
    }
    info("Debugger initialized");
}

void toggle_breakpoint(Breakpoint *breakpoint) {
    breakpoint->is_active = !breakpoint->is_active;
    info("%s breakpoint at 0x%x", (breakpoint->is_active ? "Enabling" : "Disabling"), breakpoint->offset);
    FILE *file = fopen(debugger->copy_filename, "rb+");
    fseek(file, breakpoint->offset, SEEK_SET);
    int data = (breakpoint->is_active ? 0xcc : breakpoint->instruction);
    fwrite(&data, 2, 1, file);
    fclose(file);
}

void enable_breakpoint(Breakpoint *breakpoint) {
    if (breakpoint->is_active) return;
    toggle_breakpoint(breakpoint);
}

void disable_breakpoint(Breakpoint *breakpoint) {
    if (!breakpoint->is_active) return;
    toggle_breakpoint(breakpoint);
}

void debugger_find_vulnerable_functions() {
    info("Looking for vulnerable functions");
    FILE *fp;
    char cmd[256];
    char output[1024];
    char *ptr;
    char *strtok_ptr;
    const char *delim = " \t\n";
    char *token;
    int offset = 0;
    int found_functions = 0;

    int should_add_breakpoint = 0;
    int breakpoint_instruction = 0;

    snprintf(cmd, sizeof(cmd), "objdump -d %s", debugger->copy_filename);

    // Call objdump and read its output
    fp = popen(cmd, "r");
    if (!fp) {
        error_exit(E_OBJDUMP_FAILED);
    }

    while (fgets(output, sizeof(output), fp)) {
        if (should_add_breakpoint) {
            int b_offset = (int) strtol(output + OBJDUMP_ADDRESS_OFFSET, NULL, 16);
            char instruction[3] = "";
            strncpy(instruction, output + OBJDUMP_INSTRUCTION_OFFSET, 2);
            breakpoint_instruction = (int) strtol(instruction, NULL, 16);
            info("Adding breakpoint at 0x%x", b_offset);
            Breakpoint breakpoint = {b_offset, breakpoint_instruction, 0};
            debugger->breakpoints[found_functions++] = breakpoint;
            should_add_breakpoint = 0;
        }
        for (int i = 0; i < VULN_FUNCTIONS_COUNT; i++) {
            ptr = strstr(output, "call");
            if (!ptr) continue;
            ptr = strstr(output, VULN_FUNCTIONS[i]);
            if (!ptr) continue;
            token = strtok_r(ptr, delim, &strtok_ptr);
            if (token) {
                offset = (int) strtol(output + OBJDUMP_ADDRESS_OFFSET, NULL, 16);
                info("Found %s at offset 0x%x", VULN_FUNCTIONS[i], offset);
                should_add_breakpoint = 1;
            }
        }
    }
    pclose(fp);

    debugger->breakpoint_count = found_functions;

    if (!found_functions) error_exit(E_NO_VULN_FUNCTIONS);
    info("Unsafe function calls found: %d", found_functions);
}

void find_buffer_size() {
    info("Calculating buffer size");
    commonData->buffer_size = 0;
    char payload[MAX_PAYLOAD] = "";
    do {
        sprintf(payload + commonData->buffer_size++, "%s", "A");
        if (commonData->buffer_size >= MAX_PAYLOAD) error_exit(E_MAX_PAYLOAD);
    } while (execute_program(payload) == 0);
    info("Buffer size: %d", commonData->buffer_size);
}

int execute_program(char *payload) {
    switch (commonData->input_method) {
        case ARGS: {
            char cmd[MAX_COMMAND + MAX_PAYLOAD] = "";
            sprintf(cmd, "./%s %s", debugger->copy_filename, payload);
            int n = system(cmd);
            return n;
            break;
        }
        case STDIN:
            error_exit(E_STDIN_INPUT_METHOD);
            break;
    }
    return -1;
}

void find_eip_offset_and_buffer_address() {
    info("Looking for eip offset");

    char payload[MAX_PAYLOAD] = "";
    strcpy(payload, OVERFLOW_PATTERN);
    char *filename = debugger->copy_filename;
    pid_t child_pid;
    int status;
    struct user_regs_struct regs;
    char *args[] = {filename, payload, NULL};

    child_pid = fork();
    if (child_pid == 0) {
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        execv(filename, args);
    } else {
        waitpid(child_pid, &status, 0);
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);

        waitpid(child_pid, &status, 0);

        ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
        info("EIP: 0x%lx", regs.eip);
        info("ESP: 0x%lx", regs.esp);
        char eip[5];
        sprintf(eip, "%c%c%c%c", (char) regs.eip, (char) (regs.eip >> 8), (char) (regs.eip >> 16),
                (char) (regs.eip >> 24));
        commonData->eip_offset = strstr(OVERFLOW_PATTERN, eip) - OVERFLOW_PATTERN;
        if (commonData->eip_offset <= 0) error_exit(E_INVALID_EIP_OFFSET);
        info("EIP offset: %d", commonData->eip_offset);
        ptrace(PTRACE_DETACH, child_pid, NULL, NULL);
        kill(child_pid, SIGTERM);
    }
}
