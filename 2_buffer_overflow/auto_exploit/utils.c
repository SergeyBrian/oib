#include "utils.h"

char *OVERFLOW_PATTERN = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2";

static char ERROR_TEXT[20][250] = {
        "No error",
        "Invalid command line arguments",
        "ASLR is enabled. Buffer overflow won't work",
        "Can't create a copy of target program to analyse it",
        "Can't open target program file",
        "Can't start objdump",
        "Vulnerable functions not found in target program",
        "Can't start target program",
        "Max payload length reached",
        "Stdin input method not implemented yet. Use args",
        "Buffer size is not found",
        "Invalid EIP offset. The payload doesn't properly overwrite the eip register"
};
static char WARNING_TEXT[20][250] = {
        "No warning",
        "Can't open /proc/sys/kernel/randomize_va_space file to check if ASLR is enabled"
};

static LOG_LEVEL logLevel = DEFAULT_LOG_LEVEL;

void show_error_message(char *msg) {
    if (logLevel < ERR) return;
    printf("[ERROR] %s\n", msg);
}

void show_warning_message(char *msg) {
    if (logLevel < WARN) return;
    printf("[WARNING] %s\n", msg);
}

void info(char *msg, ...) {
    if (logLevel < INFO) return;
    va_list args;
    va_start(args, msg);
    printf("[INFO] ");
    vprintf(msg, args);
    printf("\n");
    va_end(args);
}

void error_exit(ERROR error) {
    show_error_message(ERROR_TEXT[error]);

    exit((int) error);
}

void warning(WARNING warn) {
    show_warning_message(WARNING_TEXT[warn]);
}

int is_aslr_enabled() {
    FILE *fp;
    char buf[256];
    int value;

    fp = fopen("/proc/sys/kernel/randomize_va_space", "r");
    if (!fp) {
        warning(W_FAILED_TO_OPEN_ASLR_FILE);
        return -1;
    }

    if (!fgets(buf, sizeof(buf), fp)) {
        fclose(fp);
        warning(W_FAILED_TO_OPEN_ASLR_FILE);
        return -1;
    }

    if (sscanf(buf, "%d", &value) != 1) {
        fclose(fp);
        warning(W_FAILED_TO_OPEN_ASLR_FILE);
        return -1;
    }

    fclose(fp);

    return (value != 0);
}

int does_file_exist(char *filename) {
    return (access(filename, F_OK) == 0);
}

void set_log_level(int level) {
    logLevel = (LOG_LEVEL) level;
}


